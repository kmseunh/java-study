# 배열, 다차원 배열, ArrayList

_2024.05.10_

## 배열

배열은 동일한 유형의 데이터 요소를 저장하는 데 사용되는 데이터 구조를 말한다. 배열은 연속된 메모리 위치에 요소를 저장하며, 각 요소는 배열 내에서 고유한 인덱스를 가진다.

- 배열을 사용하면 자료형이 가은 자료 여러 개를 한번에 관리할 수 있다.
- 배열은 고정 크기로 생성되며 크기를 변경할 수 없다.

#### 1. 배열 선언 및 초기화

배열을 사용하려면 먼저 배열을 선언해야 한다.

```java
// 배열 선언 문법
자료형[] 배열 이름 = new 자료형[개수];
자료형 배열 이름[] = new 자료형[개수];
```

배열을 이루는 각각 자료를 배열 요소라고 하며, 배열 요소는 자료형이 모두 같다.

```java
//예제 코드
int[] studentIDs = new int[10];     //int형 요소가 10개인 배열 선언
```

- 자료형이 `int`이므로 배열 요소를 저장할 수 있는 공간의 크기는 전부 4바이트로 동일하다.

##### 배열 초기화

```java
//배열을 선언하고 동시에 값을 할당함
int[] studentIDs = new int[]{103, 102, 103};

//배열의 크기를 이미 명시했는데 다시 크기를 지정하려 함(error)
int[] studentIDs = new[3] {103,102,103};

// 배열을 선언하고 값을 할당하지만, 배열의 크기를 명시적으로 지정 x
// 배열의 크기는 할당된 값의 수에 따라 자동으로 결정됨
int[] studentIDs = {103, 102, 103};
```

#### 2. 배열 사용하기

선언한 배열의 각 요소에 값을 넣을 때나 배열 요소에 있는 값을 가져올 때는 `[]`를 사용한다.

```java
//예제 코드
studentIDs[0]=10; //배열의 첫 번째 요소에 값 10을 저장
```

- 인덱스 연선자 `[]`
    - `[]`는 배열을 처음 선언할 때 사용한 연산자로 배열 이름에 `[]`를 사용하는 것을 인덱스 연산이라고 한다.
    - 배열 요소가 저장된 메모리 위치를 찾아주는 역할
    - ex. `studentIDs[0]`은 배열 `studentIDs`의 첫 번째 요소를 나타낸다.
- 배열 순서는 0번부터
    - 배열 길이가 n이라고 하면, 배열 순서는 0번부터 `n-1`번까지
    - ex. 배열의 길이가 3이면 인덱스는 0, 1, 2가 된다.
- 전체 배열 길이와 유효한 요소 값
    - 배열의 길이와 배열에 저장된 실제 유효한 요소의 개수는 다를 수 있다.
    - ex. 배열의 길이가 5인데, 실제로는 3개의 요소만 유효하게 사용되고 나머지는 비어있다면, 배열의 길이는 5이지만 유효한 값은 3개

#### 3. 객체 배열 vs 기본 자료형 배열

##### 객체 배열 (Object Array)

객체 배열은 객체에 대한 참조(`reference`)를 저장하는 배열로, 배열의 각 요소는 객체를 가리키는 변수이다. 객체 배열을 사용하여 다수의 객체를 담고 관리할 수 있다.

- **객체 참조 저장:** 배열 요소에는 실제 객체가 아니라 해당 객체에 대한 참조(`reference`)가 저장된다.
- **초기화:** 객체 배열을 초기화할 때는 각 요소에 객체를 생성하고 그 참조를 할당해야 한다.
- **Null 처리:** 배열의 요소는 기본적으로 `null`로 초기화되며, 객체가 할당되지 않은 요소는 `null` 상태가 된다.
- **복사:** 객체 배열을 다른 배열로 복사할 때는 각 요소의 참조를 복사하는 것이므로 객체가 공유된다.

##### 기본 자료형 배열 (Primitive Type Array)

기본 자료형 배열은 기본 자료형의 값을 직접 저장하는 배열로, 배열의 각 요소는 해당 자료형의 값을 가진다. 주로 숫자, 문자, 부울 등을 저장하는데 사용된다.

- **값 저장:** 배열 요소에는 해당 자료형의 값이 직접 저장됩니다.
- **초기화:** 기본 자료형 배열을 초기화할 때는 각 요소에 해당 자료형의 값을 직접 할당합니다.
- **기본값으로 초기화:** 배열의 요소는 해당 자료형의 기본값으로 자동 초기화됩니다. 예를 들어, int 배열의 각 요소는 0으로 초기화됩니다.
- **복사:** 기본 자료형 배열을 다른 배열로 복사할 때는 각 요소의 값을 복사하는 것이므로 서로 독립적입니다.

#### 4. 배열 복사하기

기존 배열과 자료형 및 배열 크기가 똑같은 배열을 새로 만들거나 배열의 모든 요소에 자료가 꽉차서 더 큰 배열을 만들어 기존 배열에 저장된 자료를 더 가져오려 할 때 배열을
복사한다.

배열 복사는 얕은 복사(shallow copy)와 깊은 복사(deep copy) 두 가지 방식으로 할 수 있다. 이 두 가지 방식은 복사하는 데이터의 구조와 참조에 따라 다르다.

##### 얕은 복사 (Shallow Copy)

얕은 복사는 원본 배열의 요소들을 새로운 배열에 복사하는 것이지만, 각 요소가 참조하는 객체들은 복사되지 않고 그대로 유지된다. 즉, 복사된 배열과 원본 배열은 같은 객체를
참조한다.

- **동작 방식:** 얕은 복사는 배열의 요소들을 하나씩 새로운 배열에 복사한다. 만약 배열이 객체에 대한 참조를 가지고 있다면, 복사된 배열도 같은 객체를 참조한다.

```java
// 원본 배열
int[] originalArray = {1, 2, 3};

// 얕은 복사
int[] copiedArray = originalArray.clone();
```

##### 깊은 복사 (Deep Copy)

깊은 복사는 원본 배열의 요소들과 해당 객체들을 모두 새로운 배열에 복사한다. 복사된 배열과 원본 배열은 완전히 독립적인 객체를 가진다.

- **동작 방식:** 깊은 복사는 배열의 요소들을 하나씩 복사하면서, 객체에 대한 새로운 인스턴스를 생성하여 새로운 배열에 할당한다.

```java
// 원본 배열
Student[] originalArray = {new Student("Alice"), new Student("Bob")};

// 깊은 복사
Student[] copiedArray = new Student[originalArray.length];
for(int i = 0; i < originalArray.length; i++){
    copiedArray[i] = new Student(originalArray[i]);
}
```

> 깊은 복사는 객체의 내용을 완전히 복사하기 때문에, 복사된 배열과 원본 배열은 완전히 독립적이다. 따라서 하나의 배열을 변경해도 다른 배열에는 영향을 주지 않는다.

## 다차원 배열

다차원 배열은 배열의 배열로 구성된 배열로, 배열 요소가 다시 배열인 배열의 형태를 띈다. 다차원 배열은 2차원 배열, 3차원 배열 등으로 나타낼 수 있다.

- **2차원 배열:** 1차원 배열을 요소로 갖는 배열. 행(`row`)과 열(`column`)의 구조.
- **3차원 배열:** 2차원 배열을 요소로 갖는 배열. 3차원 공간을 나타내며, 면(`plane`), 행(`row`), 열(`column`)의 구조.
- **N차원 배열:** 위와 같은 방식으로 N차원 배열을 정의할 수 있다.

2차원 배열 예제

```java
// 2차원 배열 생성
int[][] twoDArray = new int[3][2];

// 값 할당
twoDArray[0][0]=1;
twoDArray[0][1]=2;
twoDArray[1][0]=3;
twoDArray[1][1]=4;
twoDArray[2][0]=5;
twoDArray[2][1]=6;

// 값 출력
for(int i = 0; i < 3; i++){
    for(int j = 0; j < 2; j++){
        System.out.print(twoDArray[i][j]+" ");
    }
    System.out.println();
}
```

3차원 배열 예제

```java
// 3차원 배열 생성
int[][][] threeDArray = new int[2][3][2];

// 값 할당
threeDArray[0][0][0]=1;
threeDArray[0][0][1]=2;
threeDArray[0][1][0]=3;
threeDArray[0][1][1]=4;
threeDArray[0][2][0]=5;
threeDArray[0][2][1]=6;

threeDArray[1][0][0]=7;
threeDArray[1][0][1]=8;
threeDArray[1][1][0]=9;
threeDArray[1][1][1]=10;
threeDArray[1][2][0]=11;
threeDArray[1][2][1]=12;

// 값 출력
for(int i = 0; i < 2; i++){
    for(int j = 0; j < 3; j++){
        for(int k = 0; k < 2; k++){
            System.out.print(threeDArray[i][j][k]+" ");
        }
        System.out.println();
    }
    System.out.println();
}
```

> 다차원 배열은 각 차원마다 인덱스를 사용하여 요소에 접근한다.

## ArrayList 클래스

`ArrayList` 클래스는 동적 배열을 구현하는 데 사용된다. 이 클래스는 크기를 동적으로 조정할 수 있는 배열로 구현되어 있어, 요소를 추가하거나 삭제할 때 배열의 크기를
신경 쓸 필요가 없다.

#### 주요 기능

- **크기 조정:** 요소를 추가하거나 삭제함에 따라 `ArrayList`의 크기가 자동으로 조정된다.
- **인덱스 기반 접근:** 인덱스를 사용하여 요소에 접근하고 수정할 수 있다.
- **반복자 지원:** `Iterator`나 `enhanced for loop`를 사용하여 `ArrayList`의 모든 요소에 접근할 수 있다.

#### 주요 메서드

- `add(E element)`: ArrayList에 요소를 추가한다.
- `get(int index)`: 해당 인덱스에 있는 요소를 반환한다.
- `set(int index, E element)`: 해당 인덱스에 있는 요소를 주어진 요소로 교체한다.
- `remove(int index)`: 해당 인덱스에 있는 요소를 제거한다.
- `size()`: ArrayList의 크기를 반환한다.
- `isEmpty()`: ArrayList가 비어 있는지 확인한다.

```java
//예제 코드

import java.util.ArrayList;

public class ArrayListExample {

    public static void main(String[] args) {
        // Integer 형식의 ArrayList 생성
        ArrayList<Integer> numbers = new ArrayList<>();

        // 요소 추가
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);

        // 요소 수정
        numbers.set(1, 25); // index 1의 요소를 25로 변경

        // 요소 제거
        numbers.remove(0); // index 0의 요소를 제거

        // 요소 출력
        for (Integer num : numbers) {
            System.out.println(num);
        }

        // 크기 출력
        System.out.println("Size: " + numbers.size());

        // ArrayList가 비어 있는지 확인
        System.out.println("Is Empty: " + numbers.isEmpty());
    }
}
```

- `Integer` 형식의 `ArrayList`를 생성하고, 요소를 추가하고 수정하고 제거한다.